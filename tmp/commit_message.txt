diff --git a/pyproject.toml b/pyproject.toml
index 82b70b4..df22b96 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -9,6 +9,7 @@ dependencies = [
     "python-dotenv>=1.1.0",
     "prompt-toolkit>=3.0.0",
     "pyfzf>=0.2.3", # Added pyfzf
+    "rich>=14.0.0",
 ]
 
 [build-system]
diff --git a/src/qx/cli/console.py b/src/qx/cli/console.py
new file mode 100644
index 0000000..18f15d3
--- /dev/null
+++ b/src/qx/cli/console.py
@@ -0,0 +1,101 @@
+# src/qx/cli/console.py
+# This module handles rich text output using the rich library.
+
+from typing import Optional
+
+from rich.console import Console
+from rich.status import Status
+from rich.theme import Theme as RichTheme # Renamed to avoid conflict
+
+# Create a standard Rich Console - this will be the base for qx_console
+# It can be re-initialized with a theme later.
+_initial_rich_console = Console(force_terminal=True)
+
+
+class QXConsole:
+    """
+    A wrapper around rich.console.Console to provide QX-specific console utilities.
+    This class manages a single Rich Console instance that can be themed.
+    """
+
+    def __init__(self, initial_console: Console):
+        self._console = initial_console
+
+    def print(self, *args, **kwargs):
+        """
+        Prints to the console using the underlying rich Console.
+        """
+        return self._console.print(*args, **kwargs)
+
+    def status(self, *args, **kwargs) -> Status:
+        """
+        Displays a status message with a spinner.
+        Forwards to the underlying rich Console's status method.
+        """
+        return self._console.status(*args, **kwargs)
+
+    def apply_theme(self, theme: RichTheme):
+        """
+        Applies a new theme to the console.
+        This re-initializes the internal Rich Console instance.
+        """
+        self._console = Console(theme=theme, force_terminal=True)
+        # Potentially log theme application here if a logger is available/passed
+
+    def __getattr__(self, name):
+        """Forward all other attribute access to the underlying console."""
+        return getattr(self._console, name)
+
+
+# Create the global QXConsole instance
+qx_console = QXConsole(_initial_rich_console)
+
+
+def show_spinner(
+    message: str = "Thinking...",
+    spinner_name: str = "dots",
+    speed: float = 1.0,
+    style: str = "status.spinner",
+) -> Status:
+    """
+    Display a spinner with the given message using the global qx_console.
+
+    Args:
+        message: The message to display alongside the spinner.
+        spinner_name: The type of spinner to be used (e.g., "dots", "line", "moon").
+        speed: The speed of the spinner.
+        style: The style to apply to the spinner.
+
+    Returns:
+        A rich.status.Status object that can be updated or stopped.
+    """
+    # Ensure spinner uses the potentially themed qx_console
+    return qx_console.status(
+        message,
+        spinner=spinner_name,
+        speed=speed,
+        spinner_style=style,
+    )
+
+
+if __name__ == "__main__":
+    # Example usage:
+    import time
+    from rich.theme import Theme as RichThemeExample
+
+    # Example of applying a theme (optional)
+    custom_theme = RichThemeExample({"status.spinner": "bold blue", "info": "dim cyan"})
+    qx_console.apply_theme(custom_theme)
+
+    spinner = show_spinner("Processing your request...", style="status.spinner")
+    with spinner:
+        time.sleep(3)
+        spinner.update("Almost done...")
+        time.sleep(2)
+    qx_console.print("[green]Done![/green]")
+
+    with show_spinner("Another task...", spinner_name="moon") as status:
+        time.sleep(3)
+        status.update("Finalizing...")
+        time.sleep(2)
+    qx_console.print("Task complete.", style="info")
diff --git a/src/qx/core/constants.py b/src/qx/core/constants.py
index 2391da1..26fed2a 100644
--- a/src/qx/core/constants.py
+++ b/src/qx/core/constants.py
@@ -32,6 +32,23 @@ DEFAULT_TREE_IGNORE_PATTERNS = [
     "coverage_reports",
     "htmlcov",
     ".coverage",
+    "package-lock.json",
+    "yarn.lock",
+    "yarn-error.log",
+    "npm-debug.log",
+    "*.class",
+    "*.jar",
+    "*.war",
+    "*.ear",
+    ".settings",
+    ".classpath",
+    ".project",
+    # R-specific patterns
+    ".Rhistory",
+    ".RData",
+    "*.Rproj",
+    ".Ruserdata",  # Simpler form of .Ruserdata/
+    "renv",  # Simpler form of renv/
 ]
 
 DEFAULT_PROHIBITED_COMMANDS = [
@@ -366,4 +383,3 @@ CLI_THEMES = {
         "markdown.hr": "dim black",
     },
 }
-
diff --git a/src/qx/main.py b/src/qx/main.py
index f8d42d6..b6ed1ee 100644
--- a/src/qx/main.py
+++ b/src/qx/main.py
@@ -3,12 +3,13 @@ import logging
 import os
 import sys
 
-from rich.console import Console as RichConsole
 from rich.panel import Panel
 from rich.text import Text
-from rich.theme import Theme
+from rich.theme import Theme as RichTheme # Keep for creating theme objects
 
+# QX imports
 from qx.cli.qprompt import get_user_input
+from qx.cli.console import qx_console, show_spinner # Import global console and spinner
 from qx.core.config_manager import load_runtime_configurations
 from qx.core.constants import (
     DEFAULT_MODEL,
@@ -17,13 +18,11 @@ from qx.core.constants import (
     DEFAULT_CLI_THEME
 )
 from qx.core.llm import initialize_llm_agent, query_llm
-from qx.core.approvals import ApprovalManager # Import ApprovalManager
+from qx.core.approvals import ApprovalManager
 from pydantic_ai.messages import ModelMessage
 from typing import List, Optional, Any
 
 # --- Configure logging for the application ---
-# Determine log level from environment variable QX_LOG_LEVEL
-# Defaults to ERROR if not set or invalid.
 log_level_name = os.getenv("QX_LOG_LEVEL", "ERROR").upper()
 LOG_LEVELS = {
     "DEBUG": logging.DEBUG,
@@ -35,7 +34,7 @@ LOG_LEVELS = {
 effective_log_level = LOG_LEVELS.get(log_level_name, logging.ERROR)
 
 logging.basicConfig(
-    level=effective_log_level, 
+    level=effective_log_level,
     format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
 )
 logger = logging.getLogger("qx")
@@ -43,13 +42,9 @@ logger.info(f"QX application log level set to: {logging.getLevelName(effective_l
 # --- End logging configuration ---
 
 
-# Global console instance - will be themed and potentially reassigned in _async_main
-q_console = RichConsole()
-
-
 async def _async_main():
     """Asynchronous main function to handle the QX agent logic."""
-    global q_console
+    # qx_console is now imported and globally available
 
     load_runtime_configurations()
 
@@ -61,9 +56,7 @@ async def _async_main():
             selected_theme_name = theme_name_from_env
             logger.info(f"Using CLI theme from environment variable: {selected_theme_name}")
         else:
-            # Use a basic console for this warning if q_console isn't themed yet
-            temp_console = RichConsole()
-            temp_console.print(
+            qx_console.print( # Use qx_console directly
                 f"[yellow]Warning:[/yellow] CLI_THEME environment variable '{theme_name_from_env}' is invalid. "
                 f"Available themes: {list(CLI_THEMES.keys())}. "
                 f"Falling back to default theme: {DEFAULT_CLI_THEME}.",
@@ -77,9 +70,7 @@ async def _async_main():
 
     final_theme_dict = CLI_THEMES.get(selected_theme_name)
     if not final_theme_dict:
-        # Use a basic console for this error if q_console isn't themed yet
-        temp_console = RichConsole()
-        temp_console.print(
+        qx_console.print( # Use qx_console directly
             f"[bold red]Error:[/bold red] Selected theme '{selected_theme_name}' not found in CLI_THEMES. "
             f"Using a basic console without full custom theming."
         )
@@ -89,19 +80,17 @@ async def _async_main():
         )
     else:
         try:
-            rich_theme_obj = Theme(final_theme_dict)
-            q_console = RichConsole(theme=rich_theme_obj)
+            rich_theme_obj = RichTheme(final_theme_dict)
+            qx_console.apply_theme(rich_theme_obj) # Apply theme to the global qx_console
             logger.info(f"Successfully applied CLI theme: {selected_theme_name}")
         except Exception as e:
-            # Use a basic console for this error
-            temp_console = RichConsole()
-            temp_console.print(f"[bold red]Error applying theme '{selected_theme_name}': {e}. Using basic console.[/bold red]")
+            qx_console.print(f"[bold red]Error applying theme '{selected_theme_name}': {e}. Using basic console.[/bold red]")
             logger.error(f"Error applying theme '{selected_theme_name}': {e}. Using basic console.", exc_info=True)
 
-    # Instantiate ApprovalManager after the console is potentially themed
-    approval_manager = ApprovalManager(console=q_console)
+    # Instantiate ApprovalManager with the (now potentially themed) global qx_console
+    approval_manager = ApprovalManager(console=qx_console)
 
-    q_console.print(
+    qx_console.print(
         Panel(
             Text("Welcome to QX - Your AI Coding Agent by Transparently.AI", justify="center"),
             title="QX Agent",
@@ -114,33 +103,33 @@ async def _async_main():
     location = os.environ.get("QX_VERTEX_LOCATION", DEFAULT_VERTEXAI_LOCATION if project_id else None)
 
     if not model_name_from_env:
-        q_console.print(
+        qx_console.print(
             "[error]Critical Error:[/] QX_MODEL_NAME missing."
         )
         sys.exit(1)
 
     if project_id and not location:
-        q_console.print(
+        qx_console.print(
             f"[warning]Warning:[/] QX_VERTEX_PROJECT_ID ('{project_id}') set, "
             f"but QX_VERTEX_LOCATION is not. Using default: '{DEFAULT_VERTEXAI_LOCATION}'.",
         )
         location = DEFAULT_VERTEXAI_LOCATION
 
-    q_console.print(f"Using Model: [info]{model_name_from_env}[/]")
+    qx_console.print(f"Using Model: [info]{model_name_from_env}[/]")
     if project_id:
-        q_console.print(f"Vertex AI Project ID: [info]{project_id}[/]")
-        q_console.print(f"Vertex AI Location: [info]{location}[/]")
+        qx_console.print(f"Vertex AI Project ID: [info]{project_id}[/]")
+        qx_console.print(f"Vertex AI Location: [info]{location}[/]")
 
     agent = initialize_llm_agent(
         model_name_str=model_name_from_env,
         project_id=project_id,
         location=location,
-        console=q_console,
+        console=qx_console, # Pass the global qx_console
         approval_manager=approval_manager
     )
 
     if agent is None:
-        q_console.print(
+        qx_console.print(
             "[error]Critical Error:[/] Failed to initialize LLM agent. Exiting."
         )
         sys.exit(1)
@@ -149,49 +138,51 @@ async def _async_main():
 
     while True:
         try:
-            user_input = await get_user_input(q_console, approval_manager)
-            
-            if user_input == "" and not approval_manager.is_globally_approved(): # Check if Ctrl+C in prompt
+            user_input = await get_user_input(qx_console, approval_manager)
+
+            if user_input == "" and not approval_manager.is_globally_approved():
                 continue
 
             if user_input.lower() in ["exit", "quit"]:
-                q_console.print("Exiting QX. Goodbye!", style="info")
+                qx_console.print("Exiting QX. Goodbye!", style="info")
                 break
-            if not user_input.strip(): 
+            if not user_input.strip():
                 continue
 
-            run_result: Optional[Any] = await query_llm(
-                agent, user_input, message_history=current_message_history, console=q_console
-            )
+            run_result: Optional[Any] = None
+            with show_spinner("QX is thinking..."): # Use the spinner
+                run_result = await query_llm(
+                    agent, user_input, message_history=current_message_history, console=qx_console
+                )
 
             if run_result:
-                q_console.print("\n[title]QX:[/]")
+                qx_console.print("\n[title]QX:[/]")
                 if hasattr(run_result, 'output'):
-                    q_console.print(run_result.output)
+                    qx_console.print(run_result.output)
                     if hasattr(run_result, 'all_messages'):
                         current_message_history = run_result.all_messages()
                     else:
                         logger.warning("run_result is missing 'all_messages' attribute.")
                 else:
                     logger.error(f"run_result is missing 'output' attribute. run_result type: {type(run_result)}, value: {run_result}")
-                    q_console.print("[error]Error:[/] Unexpected response structure from LLM.")
+                    qx_console.print("[error]Error:[/] Unexpected response structure from LLM.")
             else:
-                q_console.print(
+                qx_console.print(
                     "[warning]Info:[/] No response generated or an error occurred.",
                 )
 
         except KeyboardInterrupt:
-            q_console.print("\nOperation cancelled by Ctrl+C. Returning to prompt.", style="warning")
-            current_message_history = None 
-            continue 
+            qx_console.print("\nOperation cancelled by Ctrl+C. Returning to prompt.", style="warning")
+            current_message_history = None
+            continue
         except asyncio.CancelledError:
-            q_console.print("\nOperation cancelled (async). Returning to prompt.", style="warning")
+            qx_console.print("\nOperation cancelled (async). Returning to prompt.", style="warning")
             current_message_history = None
             continue
         except Exception as e:
             logger.error(f"An unexpected error occurred in the main loop: {e}", exc_info=True)
-            q_console.print(f"[error]Critical Error:[/] An unexpected error occurred: {e}")
-            q_console.print("Exiting QX due to critical error.", style="error")
+            qx_console.print(f"[error]Critical Error:[/] An unexpected error occurred: {e}")
+            qx_console.print("Exiting QX due to critical error.", style="error")
             break
 
 
@@ -199,17 +190,15 @@ def main():
     try:
         asyncio.run(_async_main())
     except KeyboardInterrupt:
-        console_to_use = q_console if 'q_console' in globals() and q_console else RichConsole()
-        console_to_use.print("\nQX terminated by user.", style="info")
+        # qx_console is imported and globally available
+        qx_console.print("\nQX terminated by user.", style="info")
         sys.exit(0)
     except Exception as e:
-        # Ensure logger is available at this stage, even if basicConfig failed somehow
-        # (though it's unlikely if the script reaches here)
         fallback_logger = logging.getLogger("qx.critical")
         fallback_logger.critical(f"Critical error running QX: {e}", exc_info=True)
         
-        console_to_use = q_console if 'q_console' in globals() and q_console else RichConsole()
-        console_to_use.print(f"[bold red]Critical error running QX:[/bold red] {e}")
+        # qx_console is imported and globally available
+        qx_console.print(f"[bold red]Critical error running QX:[/bold red] {e}")
         sys.exit(1)
 
 
diff --git a/tmp/commit_message.txt b/tmp/commit_message.txt
index c20bee6..3219b1e 100644
--- a/tmp/commit_message.txt
+++ b/tmp/commit_message.txt
@@ -1,8 +1,31 @@
-fix: Ensure Ctrl+C during async operations returns to prompt
+feat: Implement shell command permissions and configurable logging
 
-Refined KeyboardInterrupt (Ctrl+C) handling in `src/qx/main.py` to ensure that interrupting an asynchronous operation (e.g., while QX is "thinking") returns the user to the input prompt instead of exiting the application.
+This commit introduces a comprehensive shell command permission system and makes the application's log level configurable via an environment variable.
 
-- Added an `except asyncio.CancelledError:` block to the main loop in `_async_main`. When a `KeyboardInterrupt` occurs during an `await` call, `asyncio.run()` cancels the main task, raising `asyncio.CancelledError`. This new handler catches the error, prints a message, optionally clears `current_message_history`, and then `continue`s the loop, effectively returning to the prompt.
-- This prevents the `KeyboardInterrupt` from propagating up and causing the application to terminate.
-- The existing `except KeyboardInterrupt:` in `_async_main` remains for synchronous interrupts.
-- Updated `.Q/projectlog.md` to reflect this more robust handling.
\ No newline at end of file
+Key changes:
+
+Shell Command Permission System:
+- Added `DEFAULT_APPROVED_COMMANDS` and updated `DEFAULT_PROHIBITED_COMMANDS` in `src/qx/core/constants.py` with more comprehensive lists and fnmatch patterns.
+- Enhanced `ApprovalManager` (`src/qx/core/approvals.py`):
+    - Implemented `get_command_permission_status` to check commands against prohibited/approved lists using fnmatch.
+    - Modified `request_approval` to handle different operation types (e.g., "shell_command"), return detailed `ApprovalDecision`, and manage a "Modify" flow for commands.
+- Implemented `ExecuteShellTool` (`src/qx/tools/execute_shell.py`):
+    - Defined `ShellCommandInput` and `ShellCommandOutput` Pydantic models.
+    - The tool uses `ApprovalManager` to orchestrate the approval workflow, including command modification and re-evaluation.
+    - Executes commands via `subprocess.run` only after approval.
+    - Returns structured output including modification details.
+- Integration:
+    - Updated `src/qx/tools/__init__.py` to export `ExecuteShellTool`.
+    - Refactored `src/qx/core/llm.py` (`initialize_llm_agent`):
+        - Instantiated `ExecuteShellTool` and created a wrapper for PydanticAI agent integration.
+        - Standardized return types for all tool wrappers (`approved_read_file_tool`, `approved_write_file_tool`) to provide consistent string feedback to the LLM.
+        - Corrected `query_llm` to directly `await agent.run()`.
+
+Configurable Logging:
+- Modified `src/qx/main.py` to allow setting the application log level via the `QX_LOG_LEVEL` environment variable (DEBUG, INFO, WARNING, ERROR, CRITICAL), defaulting to ERROR.
+
+Other Changes:
+- Updated `.env` to use a newer Gemini model.
+- Added `src/qx/directives/worklogger.md` (content seems related to future worklog functionality).
+- Updated `src/qx/prompts/system-prompt.md` with an `<extended-directives>` placeholder.
+- Updated `.Q/projectlog.md` to reflect these developments.
\ No newline at end of file
diff --git a/uv.lock b/uv.lock
index bc28e3b..46ddc37 100644
--- a/uv.lock
+++ b/uv.lock
@@ -890,6 +890,7 @@ dependencies = [
     { name = "pydantic-ai" },
     { name = "pyfzf" },
     { name = "python-dotenv" },
+    { name = "rich" },
 ]
 
 [package.dev-dependencies]
@@ -903,6 +904,7 @@ requires-dist = [
     { name = "pydantic-ai", specifier = ">=0.2.4" },
     { name = "pyfzf", specifier = ">=0.2.3" },
     { name = "python-dotenv", specifier = ">=1.1.0" },
+    { name = "rich", specifier = ">=14.0.0" },
 ]
 
 [package.metadata.requires-dev]
